<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ„ ç²’å­åœ£è¯æ ‘</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: sans-serif;
    }
    #overlay {
      position: absolute;
      width: 100%;
      text-align: center;
      top: 10%;
      color: #ff80aa;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 0 0 10px #ff80aa, 0 0 20px #ff80aa, 0 0 30px #ff80aa;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="overlay">Merry Christmas ğŸ„</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let particles = [];
    let starParticles = [];
    const particleCount = 1500;
    const starCount = 300;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // ç²’å­æè´¨
      const particleMaterial = new THREE.PointsMaterial({
        color: 0xff4d6d,
        size: 0.5,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });

      // åˆ›å»ºåœ£è¯æ ‘å½¢çŠ¶ç²’å­
      const particleGeometry = new THREE.BufferGeometry();
      const positions = [];

      for (let i = 0; i < particleCount; i++) {
        // åœ£è¯æ ‘é”¥å½¢å…¬å¼: yä»åº•åˆ°é¡¶
        const y = Math.random() * 30 - 15; // -15åˆ°15
        const radius = (15 - Math.abs(y)) * (Math.random() * 0.5 + 0.5); // è¶Šä¸Šé¢è¶Šç»†
        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        positions.push(x, y, z);
        particles.push({ x, y, z, angle, radius });
      }

      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particleSystem);

      // åˆ›å»ºåº•éƒ¨æ˜Ÿç©ºç²’å­
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      const starGeometry = new THREE.BufferGeometry();
      const starPositions = [];
      for (let i = 0; i < starCount; i++) {
        const x = (Math.random() - 0.5) * 100;
        const y = (Math.random() - 0.5) * 20 - 15;
        const z = (Math.random() - 0.5) * 50;
        starPositions.push(x, y, z);
        starParticles.push({ x, y, z });
      }
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
      const starSystem = new THREE.Points(starGeometry, starMaterial);
      scene.add(starSystem);

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = scene.children[0].geometry.attributes.position.array;
      for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        // ç²’å­è½»å¾®æµ®åŠ¨
        p.angle += Math.random() * 0.02 - 0.01;
        const idx = i * 3;
        positions[idx] = Math.cos(p.angle) * p.radius;
        positions[idx + 1] = p.y + Math.sin(Date.now() * 0.001 + i) * 0.3; // ä¸Šä¸‹å¾®åŠ¨
        positions[idx + 2] = Math.sin(p.angle) * p.radius;
      }
      scene.children[0].geometry.attributes.position.needsUpdate = true;

      // æ˜Ÿæ˜Ÿé—ªçƒ
      const starPositions = scene.children[1].geometry.attributes.position.array;
      for (let i = 0; i < starParticles.length; i++) {
        const idx = i * 3 + 1;
        starPositions[idx] += Math.sin(Date.now() * 0.002 + i) * 0.05;
      }
      scene.children[1].geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
